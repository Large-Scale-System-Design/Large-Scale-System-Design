## 1주차. (내용정리) 사용자 수에 따른 규모 확장성

<br>

> (느낀점)  
> 규모 확장을 위해 어떠한 방식(서비스)들이 있는지와 해당 서비스로 규모 확장을 할 경우에 유의할 점을 제시하는 글이었음.  
> <br>
> N중화, 캐시, CDN, 메시지 큐 등은 익히 들어서 많이 알고 있었지만,  
> 무상태웹계층(sticky-session)과 샤딩에 대한 내용이 신선했음   
> <br>
> 특히 celebrity 이슈는 유투브/인스타 같은 팔로우 등에 적용되는걸로 알고 있는데 실제로 적용해보면 재밌을 듯

<br>

<br>

### 1\. 데이터베이스 선택

- 관계형 데이터베이스 vs 비관계형 데이터베이스
    - 어떨 때 관계형 데이터베이스를 쓰는지
        - **데이터의 일관성과 명확성이 중요할 때**: 금융 거래, 결제 시스템, 예약 시스템처럼 데이터가 한 치의 오차도 없이 정확하게 기록되고 변경되어야 하는 경우에 적합합니다. ACID(원자성, 일관성, 고립성, 지속성) 트랜잭션을 지원하여 데이터의 신뢰성을 보장합니다.
        - **데이터 구조가 변경될 일이 거의 없을 때**: 시스템의 요구사항이 명확하고, 데이터의 구조가 초기에 설계된 대로 유지되는 서비스에 유리합니다.
        - **복잡한 쿼리나 조인(Join)이 필요할 때**: 여러 테이블에 분산된 데이터를 관계에 따라 조합하여 복잡하고 정교한 데이터 분석이나 리포트를 생성해야 할 때 강력한 성능을 발휘합니다.

    - 어떨 때 비관계형 데이터베이스를 쓰는지
        - **대용량 데이터를 신속하게 처리해야 할 때**: 소셜 미디어 피드, IoT 기기에서 수집되는 센서 데이터, 로그 데이터처럼 엄청난 양의 데이터를 빠르고 유연하게 저장하고 조회해야 할 때 적합합니다.
        - **데이터 구조가 유연하게 변경될 수 있을 때**: 서비스 초기 단계이거나, 어떤 종류의 데이터가 쌓일지 예측하기 어려운 경우, 또는 비즈니스 요구사항에 따라 데이터 모델을 자주 변경해야 하는 경우에 유리합니다.
        - **수평적 확장이 중요할 때**: 사용자가 급증할 가능성이 높은 서비스의 경우, 여러 서버에 데이터를 분산 저장하여 시스템 전체의 성능을 쉽게 확장할 수 있습니다.
        - **읽기(Read) 작업이 매우 빈번할 때**: 쓰기(Write) 작업보다 읽기 작업의 비중이 압도적으로 높은 서비스(예: 블로그, 뉴스 사이트)에서 빠른 응답 속도를 제공할 수 있습니다.

![](Files/image.png)<br>

<br>

### 2\. 웹서버 확장

- 수직적 확장(Scale Up/Down)
    - 서버로 들어오는 트래픽 양이 적을 때는 수직적 확장이 좋은 선택
    - 장점
        - 단순함
    - 단점
        - 규모 확장에 한계가 있음(CPU, MEM을 무한대로 증설할 수 없음)
        - 장애에 대한 자동 복구(fail-over) 방안 + 다중화 방안을 제시할 수 없음
        - 장애가 발생하면 완전히 중단
    - 결론
        - 대규모 시스템 설계에는 수평적 규모 확장법이 더 적절함

- 수평적 확장(Scale In/Out)
    - 로드밸런서 + 부하/분산 → 장애가 발생한 서버를 제외하고 트래픽을 옮겨서 가용성 확보

<br>

<br>

### 3\. 데이터베이스 다중화

- Master + Slave 형태로 다중화 구성
    - 보통 읽기 연산이 쓰기 연산보다 많음. → Slave 데이터베이스의 수를 더 많이 구성
- Master에만 쓰기 연산 지원
- Master 데이터베이스가 다운되면, Slave 데이터베이스 중 1개가 Master 역할
    - 문제점: Slave 데이터베이스의 데이터가 최신이 아닐경우 → 복구 스크립트, 다중 Master, 원형 다중화 방식을 통해서 대처

<br>

<br>

### 4\. 캐시

- 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고 빠르게 처리
- 캐시 우선 읽기 전략(read-through caching strategy)
    - 캐시 먼저 읽고 없으면 DB 읽기
- 캐시를 사용할 때 유의점
    - 캐시를 사용하는 경우
        - 데이터 갱신은 자주 일어나지 않고 데이터 참조가 빈번하게 일어나는 경우
        - 영속성이 없는 데이터
    - 만료 기한 설정
    - 저장소의 원본 갱신 연산과 캐시 갱신 연산이 단일 트랜잭션으로 처리
    - 캐시 서버의 부하 분산
    - 캐시 데이터 내보내기 정책
        - LRU: 제일 오래전에 읽은 거
        - LFU: 제일 적게 읽은 거

<br>

<br>

### 5\. CDN

- 정적 콘텐츠(html)을 캐싱하는 것

<br>

<br>

### 6\. 무상태 웹계층

- 사용자에 대한 세션 및 상태 정보를 서버에서 보관하지 않고, DB에 저장
- 사용자 세션 정보를 서버에서 보관할 경우, 세션을 유지시켜줘야하는 sticky-session을 해야 하는데, 이는 로드밸런서에 부하가 많이 가는 작업
    - 따라서 상태 정보는 웹서버와 분리된 공유 저장소에 저장되어야 안정적이며 규모 확장이 쉬움

<br>

<br>

### 7\. 데이터 센터

- 더 큰 규모의 다중화 (지역, 자연재해 감안)

<br>

<br>

### 8\. 메시지 큐

- 메시지를 소비자가 꺼낼 때까지 안전히 보관하는 “무손실"을 보장하는 비동기 통신 지원 컴포넌트
- 발행자가 메시지를 발행하고, 구독자가 메시지를 읽고 이에 맞는 동작을 수행
- 서버간 결합이 느슨해져서, 규모 확장성이 보장

<br>

<br>

### 9\. 로그 / 메트릭 / 자동화

- 로그: 로그 단일 서비스로 모아주는 도구를 활용하면 더 좋음
- 메트릭
    - 호스트 단위 메트릭: CPU, MEM, I/O
    - 종합 메트릭: DB 성능, 캐시 성능
    - 핵심 비즈니스 메트릭: 사용자, 수익, 재방문 등

<br>

<br>

### 10\. 샤딩

- 샤딩키(파티션키)를 어떻게 정하느냐가 중요함
    - 데이터 재샤딩: 아래의 경우, 샤드키를 계산하는 함수를 변경하고 데이터를 재배치해야 하는 경우가 발생할 수 있음
        - 하나의 샤드로는 감당할 수 없는 많은 데이터 + 샤드 간 데이터 분포가 균등하지 않아 특정 샤드의 공간 소모가 클 경우
    - 유명인사(핫스팟 키): 인기쟁이들(블랙핑크)이 동일한 샤드에 저장되면, 과부하가 걸림
        - 인기쟁이들은 별도의 샤드에 따로 배치(각각 샤드 하나씩 또는 더 잘게 쪼개는 등)

<br>

<br>

### 실습 과제 해보면 좋을 것 같은?

- DB 3중화 + VIP 로드밸런싱

[실습](practice.md)

<br>