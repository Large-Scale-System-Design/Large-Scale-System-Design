# 주제
- 7장: 분산 시스템을 위한 유일 ID 생성기 설계

# 내용
- 유일 ID 생성기: 유일성이 보장되는 ID를 생성하는 것
	- 기존 DB의 auto_increment는 전역적으로 유일성을 보장할 수 없기 때문에 탄생

## 1. 문제 이해 및 설계 범위 확정
### 요구사항
- ID는 유일해야 함
- ID는 숫자로만 구성돼야 함
- ID는 64비트로 표현 가능한 값
- ID는 발급 날짜에 따라 정렬 가능 ==> DB에서 정렬된 index 기준으로 최적화 돼있음
- 초당 10,000개의 ID 생성 가능

## 2. 개략적 설계안 제시 및 동의 구하기
- 다양한 유일성 보장 ID 생성 방법 중 요구사항에 충족되는 방법 선택
### 1. 다중 마스터 복제
- {DB auto_increment + 서버 수}를 ID로 사용
- 장점
	- 구현이 단순함
- 단점
	- 여러 데이터 센터에 걸쳐 규모 확장이 어려움
	- ID 값이 시간 흐름에 맞추어 커지는 것을 보장하지 않음
	- 서버 추가 / 삭제에 대한 대응이 어려움
### 2. UUID
- 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 수
- 장점
	- 서버 간 조율 없이 독립적으로 유일한 값 생성이 가능하여 규모 확장 용이
	- 동기화 불필요로 인해 구현이 단순함
- 단점
	- ID가 128비트로 길기 때문에 요구사항(64비트) 미충족
	- ID를 시간 순으로 정렬 불가
	- ID에 숫자가 아닌 값이 들어갈 수 있음
### 3. 티켓 서버
- 중앙 집중형으로 티켓 서버가 auto_incremenet로 ID 생성
- 장점
	- 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들 수 있음
	- 구현이 단순함
- 단점
	- 티켓 서버가 SPOF가 됨. 티켓 서버 장애 발생 시 전체 시스템에 영향 발생. (티켓 서버 다중화 시, 동기화 문제도 발생)
	- (추가) ID 생성 비용: 유일한 ID를 얻기 위해 티켓 서버를 거치는 비용 + 티켓 서버가 동기화를 위해 락을 거는 비용
### 4. 트위터 스노플레이크 기법
- 전체 ID 값의 크기(64비트)를 여러 섹션으로 분할하여 ID 생성
	- ID 섹션 구성 (최상위 비트부터 순차적으로)
		- 1비트 (예약 공간) 음수 / 양수 구별에 사용 가능
		- 41비트 (타임스탬프): 기원 시각(epoch) 기준으로 경과된 밀리초를 나타내는 값
		- 5비트 (데이터센터 ID): 32개의 데이터 센터 지원 가능
		- 5비트 (서버 ID): 데이터센터 당 32개의 서버 지원 가능
		- 12비트 (일련번호): 1 밀리초 동안 ID 생성 시마다 순차적으로 증가되는 값 (1 밀리초 경과 시, 0으로 초기화)

## 3. 상세 설계
- 데이터센터 ID / 서버 ID는 시스템 시작 시 결정
- 타임스탬프와 일련번호는 ID 생성기가 도는 중에 만들어지는 값
### 타임스탬프
- 타임스탬프는 시간이 흐름에 따라 항상 증가되므로, 시간 순으로 정렬 가능
- 41비트 타임스탬프 값을 통해 UTC 시각으로 변환 가능
	1. 절대값 획득: {타임스탬프} + {기원 시각}
	2. UTC 시각으로 변환
- 41비트로 최대 표현 가능한 약 69년간 사용 가능 (이후 마이그레이션 필요)
### 일련 번호
- 12비트로 4096개의 값 표현 가능
- 각각의 서버가 1 밀리초 내에 여러 ID를 생성할 때에만 1 이상으로 표현됨

## 4. 마무리
- 트위터 스노플레이크 방식을 통해 요구사항에 충족하는 유일 ID 생성기를 설계함
- 몇 가지 보완 사항 추가 논의 가능
	- 시간 동기화: 모든 서버가 동일한 시간을 기준으로 ID를 생성해야 순서 보장되므로, NTP 등을 고려
	- 각 섹션의 길이 최적화: 동시성 보다 수명이 중요한 경우, 타임스탬프 섹션의 길이를 키우는 방법 고려
	- 고가용성: ID 생성기는 필수 불가결 컴포넌트이므로, 아주 높은 가용성 필요
