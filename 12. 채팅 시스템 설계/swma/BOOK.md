# 주제
- 12장: 채팅 시스템 설계
# 1. 문제 이해 및 설계 범위 확정
## 명확한 설계의 필요성
- 채팅앱은 목적에 따라 종류가 다양하여, 면접관이 원하는 채팅앱이 어떤 것인지 확실하게 확인해야 함
### 예시
- 1:1 채팅 특화: 페이스북 메신저, 위챗, 왓츠앱
- 그룹 채팅(업무용): 슬랙
- 게임 채팅(대규모 그룹 소통 / 저지연 음성 채팅): 디스코드
## 설계 범위
- 응답지연이 낮은 1:1 채팅
- 최대 100명까지 참여 가능한 그룹 채팅
- 사용자 접속상태 표시
- 다양한 단말 지원(하나의 계정을 여러 단말에 동시 접속 지원)
- 푸시 알림
- 일별 능동 사용자 수 기준 5천만 명 처리
- 메시지 길이 100,000 자 이내
- 종단 간 암호화는 추후 고려
# 2. 개략적 설계안 제시 및 동의 구하기
## 채팅 서비스
- 클라이언트들로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자 접속 전까지 해당 메시지 보관
### 프로토콜
#### HTTP
- keep-alive 를 통해 핸드쉐이크 횟수 감소
- 메시지 전송에는 적합
- 메시지 수신(서버가 수신자에게 메시지를 전달)을 위한 기법 도입 필요
##### 폴링
- 수신자가 서버에게 새 메시지 존재 여부를 계속해서 확인 요청을 보내는 기법
- 서버 자원이 불필요하게 낭비됨
##### 롱 폴링
- 새 메시지가 발생하기 전까지 수신자가 서버와의 연결을 일정 시간(타임아웃) 유지
- 메시지 전송자와 수신자가 같은 채팅 서버에 접속하지 않을 가능성이 존재함
- 서버 입장에서 수신자의 연결 해제 여부를 확인하기 어려움
- 메시지를 많이 받지 않는 수신자도 타임아웃 시 서버에 재연결하여 비효율적
##### 웹소켓
- 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용되는 기술
- 동작과정
	1. 클라이언트->서버: HTTP 핸드셰이크 수행 (프로토콜 업그레이드)
	2. 서버->클라이언트: ACK
	3. 클라이언트<>서버: 메시지 양방향 전송
- 기존 HTTP와 동일한 포트(80 / 443)를 사용하여, 별도의 포트 개방 없이 사용 가능
- 서버에서 연결 지향 세션을 효율적으로 관리해야 함
## 개략적 설계안
<img src="docs/12_07.png" width="50%" height="50%" /><br>
### 무상태 서비스
- 로그인 / 회원가입 / 사용자 프로파일 표시 등을 처리하는 전통적인 요청/응답 서비스
- 많은 웹 사이트와 앱이 보편적으로 제공하는 기능 제공
- 로드밸런서 뒤에 위치함
- 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 서비스 탐색 서비스를 포함
### 상태 유지 서비스
- 본 설계안에서 유일하게 상태 유지가 필요한 채팅 서비스를 포함
- 클라이언트는 최초 연결된 채팅 서버와 연결을 유지함
- 서비스 탐색 서비스와 긴밀히 협력하여,, 특정 서버에 부하가 몰리지 않도록 함
### 제3자 서비스 연동
- 푸시 알림 제공 (제3장 알림 시스템 설계 참고)
### 규모 확장성
- 서버 한 대로 얼마나 많은 접속을 동시 허용 가능한 지가 중요
- SPOF 방지를 위해 서버 다중화가 필요
- 단일 서버 설계안부터 출발하여 점차 다듬어 나가는 것도 괜찮음
	- 단, 면접관에게 이것은 그저 시작일 뿐이라는 의사는 정확히 전달 필요
### 전체 설계안
<img src="docs/12_08.png" width="60%" height="60%" /><br>
- 채팅 서버: 클라이언트 사이에 메시지 중계 역할 담당
- 접속상태 서버: 사용자 접속 여부 관리
- API 서버: 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 전부를 처리
- 알림 서버: 푸시 알림 전송
- 키-값 저장소: 채팅 이력 보관을 통해 시스템 접속 사용자에게 이전 채팅 이력을 보여줌
#### 저장소
- 데이터 계층을 올바르게 만들기 위한 데이터베이스 선택 필요
- 데이터 유형 및 읽기/쓰기 연산 비율을 통해 결정 필요
- 채팅 시스템에서 다루는 데이터는 보통 두 가지
	- 일반적인 데이터: 사용자 프로파일, 설정, 친구 목록
		- 안정성을 보장하는 관계형 데이터베이스에 보관
		- 다중화 / 샤딩을 통해 데이터의 가용성과 규모확장성을 보증
	- 채팅 시스템 고유 데이터: 채팅 이력
		- 특성:
			- 채팅 이력 데이터 규모: 엄청남 (페이스북 메신저, 왓츠앱은 매일 600억 개의 메시지 처리)
			- 주 사용 데이터: 최근 메시지
			- 무작위적 데이터 접근: 검색, 특정 사용자가 언급된 메시지 열람, 특정 메시지로 점프 등
			- 읽기/쓰기 비율: 1:1
		- 키-값 저장소 추천
			- 수평적 규모확장 용이
			- 낮은 데이터 접근 지연시간
			- 관계형 데이터베이스와 달리, 롱 테일을 잘 처리함. (관계형 데이터베이스는 인덱스가 커지면 데이터 무작위 접근에 대한 처리 바용 상승)
			- 이미 많은 안정적인 채팅 시스템이 키-값 저장소 채택
				- 페이스북 메신저: HBase
				- 디스코드: 카산드라
### 데이터 모델
#### 1:1 채팅을 위한 메시지 테이블
- 기본 키 `message_id`로 메시지 순서 부여
- `created_at`은 동시에 서로 다른 두 메시지가 생성될 수 있으므로 순서 결정에 부적합
- `message` 테이블 구성:

| key            | type       |
| -------------- | ---------- |
| **message_id** | **bigint** |
| message_from   | bigint     |
| message_to     | bigint     |
| content        | text       |
| created_at     | timestamp  |
#### 그룹 채팅을 위한 메시지 테이블
- `(channel_id, message_id)`의 복합 키를 기본 키로 사용
- 채널은 채팅 그룹과 동일한 의미
- `channel_id`는 그룹 채팅에 적용된 모든 질의는 특정 채널을 대상으로 할 것이므로, 파티션 키로도 사용
- `group_message` 테이블 구성:

| key            | type       |
| -------------- | ---------- |
| **channel_id** | **bigint** |
| **message_id** | **bigint** |
| message_to     | bigint     |
| content        | text       |
| created_at     | timestamp  |
#### 메시지 ID
- `message_id`의 값은 고유해야 함
- ID 값은 시간 순서를 따라 정렬 가능해야 함
- NoSQL은 RDBMS의 auto_increment 같은 대안이 없음
- 스노우플레이크 / 지역적 순서 번호 생성기 사용
	- 지역적 순서 번호 생성기: 같은 그룹 내에서만 ID 유일성 보장
# 3. 상세 설계
## 서비스 탐색
- 클라이언트의 위치 / 서버의 용량을 고려하여 클라이언트에게 가장 적합한 채팅 서버를 추천
- 오픈소스로 Apache Zookeeper 존재
- 사용 가능한 모든 서버를 등록 후, 클라이언트 접속 시 사전 규칙에 따라 최적의 채팅 서버를 골라줌
<img src="docs/12_11.png" width="60%" height="60%" /><br>
### 동작 방식
1. 사용자가 시스템에 로그인
2. 로드밸런서가 로그인 요청을 임의의 API 서버에 전송
3. API 서버가 사용자 인증 처리 후, 서비스 탐색 기능을 통해 해당 사용자를 서비스할 최적의 채팅 서버 탐색 / 반환
4. 사용자가 해당 채팅 서버와 웹소켓으로 연결
## 메시지 흐름
### 1:1 채팅 메시지 처리 흐름
<img src="docs/12_12.png" width="60%" height="60%" /><br>
1. 사용자가 채팅 서버로 메시지 전송
2. 채팅 서버는 ID 생성기를 통해 해당 메시지의 ID 결정
3. 채팅 서버는 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지를 키-값 저장소에 보관
5. 수신자 접속 여부에 따른 메시지 처리 방식 결정
	- 수신자 미접속: 푸시 알림 서버에 메시지 전달
	- 수신자 접속: 수신자가 연결된 채팅 서버를 거쳐, 수신자에게 전달
6. 채팅 서버가 메시지를 수신자에게 전송 (웹소켓)
### 여러 단말 사이의 메시지 동기화
<img src="docs/12_13.png" width="60%" height="60%" /><br>
- 각 단말은 해당 단말 기준 가장 최신 메시지의 ID를 기록 (`cur_max_message_id`)
- 새 메시지 간주 방식
	- 수신자 ID와 현재 로그인된 사용자의 ID가 일치
	- 키-값 저장소에 보관된 메시지 중, `cur_max_message_id`보다 큰 ID를 가진 메시지
### 소규모 그룹 채팅에서의 메시지 흐름
- 위챗 방식
	- 송신자 기준으로 각 수신자의 메시지 큐에 동일한 메시지를 복사 / 전달
	- 장점:
		- 새 메시지를 확인하기 위해 자기 큐만 확인하면 되므로, 동기화 플로우가 단순함
		- 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 크지 않음
	- 단점: 많은 사용자를 지원해야 하는 경우, 복사 비용이 커서 부적합
<img src="docs/12_14.png" width="50%" height="50%" /><br>
- 보완
	- 수신자를 기준으로 하나의 메시지 큐를 통해 여러 송신자의 메시지를 관리
<img src="docs/12_15.png" width="60%" height="60%" /><br>
### 접속상태 표시
- 접속상태 서버와 웹소켓으로 통신하여 사용자 상태 관리
#### 사용자 로그인
- 클라이언트<>실시간 서비스 웹소켓 연결 수립 시, 접속상태 서버는 사용자 상태 / `last_active_at` 타임스탬프 값을 키-값 저장소에 보관
- 해당 절차 완료 시, 접속 중으로 표시
#### 로그아웃
- 키/값 저장소에 보관된 사용자 상태를 online -> offline 변경
#### 접속 장애
- 사용자의 접속 상태가 안정적이지 않은 경우를 대비하여 heartbeat 검사를 수행
- 클라이언트가 서버에 일정 주기로 heartbeat를 전달
- 서버에서 클라이언트의 heartbeat를 일정 시간 미수신 시, 오프라인으로 간주
#### 상태 정보의 전송
- 사용자와 친구 관계에 있는 타 사용자들이 해당 사용자의 상태 변화를 알기 위해, 상태정보 서버는 발행-구독 모델 사용
- 각각의 친구 관계마다 채널 부여
	- 예시: 사용자 A를 기준으로 친구 B,C,D에게 A<>B, A<>C, A<>D 와 같이 서로 연결된 채널을 하나씩 부여
- 실시간 웹소켓을 통해 상태정보 변화를 통지
- 사용자 수가 많을 경우, 그룹 채팅 입장 또는 사용자 접속상태 수동 업데이트 유도를 통해 대응
<img src="docs/12_19.png" width="60%" height="60%" /><br>
# 4. 마무리
- 1:1 및 그룹 채팅을 지원하는 채팅 시스템을 설계함
- 클라이언트<>서버 실시간 통신을 위한 웹소켓 사용
- 실시간 메시징 지원을 지원하는 채팅 서버, 접속상태 서버, 푸시 알림 서버, 채팅 이력 보관(키-값 저장소), 이를 제외한 나머지 기능 구현(API 서버) 컴포넌트 설계
## 보완사항
- 사진 / 메시지 등 미디어 지원: 압축 방식, 클라우드 저장소, 썸네일 생성 등을 논의
- 종단 간 암호화: 메시지 발신인, 수신자 이외에 메시지 열람이 불가능하도록 보안 강화
- 캐시: 클라이언트에 이미 읽은 메시지를 캐싱하여 서버 통신량 감소
- 로딩 속도 개선: 슬랙과 같이 사용자 데이터, 채널 등을 지역적으로 분산하는 네트워크 구축
- 오류 처리
	- 채팅 서버 오류: 서버가 죽을 경우, 서비스 탐색 기능(주키퍼 등)을 통해 클라이언트에게 새로운 서버 배정 후 재접속 유도
	- 메시지 재전송: 재시도 / 큐를 통해 메시지의 안정적 전송 보장
