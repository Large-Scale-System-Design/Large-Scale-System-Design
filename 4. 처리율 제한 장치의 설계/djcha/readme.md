## 4주차. 처리율 제한 장치의 설계 

<br>

1. 처리율 제한 장치: 서비스가 보내는 트래픽을 제어하는 장치
    - 기준
        - 동일한 사용자 기준 제한
        - 동일한 IP 주소를 기준 제한
        - 동일한 디바이스 기준 제한
    - 장점
        - DoS(Denial of Service) 공격 방지
        - 비용 절감: 3rd party 에 API 사용료를 지불하는 서비스
        - 서버 과부하 방지

<br>

2. 처리율 제한 장치에 대한 지식
    - 일반적으로, 클라이언트 요청은 쉽게 위변조가 가능하기 때문에, 처리율 제한을 안정적으로 걸 수 있지 못함
    - 처리율 제한 전용 미들웨어를 사용해 제한하는 방법도 있음
    - 처리율 제한 걸렸을 때, HTTP 상태 코드(429, Too Many Requests)
    - MSA 환경에서의 처리율 제한은 API Gateway를 이용
        - 처리율 제한뿐 아니라, SSL 종단 + 사용자 인증 + IP 허용 여부 등도 판단.

<br>

3. 처리율 제한 기능 설계 시
    - 기술 스택이 처리율 제한 기능을 지원할정도로 충분한지
        - 프로그래밍 언어, 캐시 서비스 등
    - 비즈니스 로직에 맞는 처리율 제한 알고리즘 고려
        - 직접 개발할 경우 알고리즘 선택의 다양성이 있지만, 제3자 제공 미들웨어의 경우에는 자유도가 떨어짐
    - 기존 MSA 구조에 미들웨어가 있는 구조라면, 처리율 제한을 미들웨어에 추가

<br>

4. 처리율 제한 알고리즘
    - 토큰 버킷: 지정된 용량을 갖는 컨테이너에 주기적으로 토큰을 채우고, 각 요청마다 토큰을 사용
        - 새로운 요청이 오면 버킷에 토큰이 있는지 확인
            - 토큰이 있는 경우, 요청 처리
            - 토큰이 없는 경우, 냅다 버리기
        - 토큰이 가득 찬 경우, 오버 플로우 된 토큰도 냅다 버리기
        - 통상적으로 API 엔드포인트마다 버킷을 생성
        - 장점
            - 구현이 쉽고, 메모리 효율적, Burst of Traffic 도 처리 가능

        - 단점
            - 버킷 크기와 토큰 공급률을 적절하게 설정하기가 까다로움

        - **API 호출 횟수 제한**
        - > A 회사는 파트너사에게 시간당 1,000개의 토큰을 제공하는 API를 운영합니다. 평소에는 파트너사가 시간당 500개의 요청만 보내지만, 특정 이벤트 기간에는 순간적으로 800개의 요청을 보낼 수 있습니다. 토큰 버킷 방식은 버킷에 미리 쌓인 토큰이 있다면, 이처럼 순간적으로 몰리는 요청을 정상적으로 처리해줄 수 있어 비즈니스 유연성을 높입니다.

<br>

    - 누출 버킷 알고리즘
        - 토큰 버킷과 비슷하지만, 처리율 고정된(사이즈가 고정된) 큐를 사용
        - 새로운 요청이 오면 큐에 자리가 있는지 확인하여 처리
        - 장점
            - 큐 사이즈가 고정(처리율 고정)이라 메모리 사용이 효율적이고, 안정적인 출력이 필요한 경우에 적합
        - 단점
            - 단시간에 많은 트래픽이 몰리는 경우 최신 요청들이 버려짐
            - 마찬가지로 큐 사이즈와 처리율을 튜닝하는 것이 까다로움
        - **온라인 게임의 스킬 사용**

> 인기 온라인 게임에서 '파이어볼' 스킬은 3초에 한 번씩만 사용할 수 있습니다. 유저가 1초 만에 스킬 버튼을 5번 연타하더라도, 시스템은 3초라는 고정된 처리 속도에 맞춰 한 번만 스킬을 발동시킵니다. 이를 통해 서버는 예측 가능한 부하만 받게 되어 안정적인 게임 환경을 제공합니다.

<br>

    - 고정 윈도우 카운터 알고리즘
        - 시간을 고정된 간격으로 나누고(윈도우), 각 윈도우마다 카운터를 설정
            - 윈도우 내에서 요청이 들어올 때마다 카운터를 1씩 증가시키고, 설정된 한도를 넘으면 요청을 차단
            - 장점
                - 메모리 효율적
                - 이해하기 쉬움
            - 단점
                - 특정 시간(윈도우)과 시간(윈도우) 사이에 일시적으로 트래픽이 몰려드는 경우, 설정한 카운터 기준 최대 2배까지 더 처리해야할 수도 있음
                    - ex. 1:00:00에 100개, 1:00:01에 100개

            - **웹사이트 게시글 작성 제한**

> 한 커뮤니티 사이트는 안정적인 운영을 위해 유저가 1분에 5개까지만 게시글을 작성할 수 있도록 제한합니다. 12시 00분 00초부터 12시 00분 59초까지 5개의 글을 썼다면, 12시 01분 00초가 되어야만 새로운 글을 작성할 수 있습니다.

<br>

    - 이동 윈도우 로깅 알고리즘
        - 고정 윈도우의 문제를 해결하기 위해 요청이 들어온 시간을 모두 기록
            - 보통 정렬(timestam 기준) 기능이 있는 자료구조(SortedSet) 같은 캐시에 보관
            - 새 요청이 들어오면 만료된 현재 시간을 기준으로 지난 윈도(ex 1분 전까지의)의 요청 기록을 확인하여 개수가 한도를 넘지 않았는지 확인
            - 장점
                - 정교하게 제어 가능
            - 단점
                - 메모리 사용 증가
            - **금융 거래 사기 방지 시스템 (FDS)**

> 카드사는 고객의 카드가 10분 이내에 3회 이상 비정상적인 장소에서 결제 시도될 경우, 이를 사기 거래로 의심하고 결제를 차단합니다. 이 시스템은 각 결제 시도 시간을 정확히 기록하고 현재 시간 기준 10분 내의 모든 기록을 추적해야 하므로 이동 윈도 로그 방식이 적합합니다.

<br>

    - 이동 윈도 카운터 알고리즘
        - 고정윈도 단순함 + 이동윈도 정확성 절충 방식
        - 이전 윈도의 카운터를 함께 사용하여 현재 요청량을 **추정**
            - 추정에 사용되는 공식: 현재 위도 요청수(카운터) + 이전 윈도 요청수(카운터) \* 겹치는 비율
                - 겹치는 비율: 현재 시간이 현재 윈도의 30%구간이면 이전 윈도와 겹치는 구간이 70%라는 뜻

        - 장점
            - 메모리 효율, 이전 시간대의 사용량 추정을 통해서 계산하므로 짧은 시간 트래픽이 몰려도 적절히 제어
        - 단점
            - 있긴한데 별로 안중요함
                - 요청이 균등할 경우, 추정치 계산이 다소 느슨하지만 심각한건 아님

        - **실시간 스트리밍 서비스 대역폭 제한**

> 동영상 스트리밍 플랫폼은 사용자에게 분당 100MB의 데이터 사용량 제한을 둡니다. 시스템은 이전 1분과 현재 1분의 데이터 사용량을 비율에 따라 조합하여 현재 시점의 사용량을 근사치로 계산합니다. 이를 통해 실시간으로 부드럽게 제한을 걸면서도 서버 자원을 효율적으로 사용하여 많은 사용자에게 안정적인 서비스를 제공할 수 있습니다.

<br>

6. HTTP(API) 처리율 제한 장치 응답에 필요한 정보
    - Status: 429(Too many requests)
    - Header
        - X-Ratelimit-Remaining: 남은 처리 가능 요청 수
        - X-Ratelimit-LImit: 매 윈도마다 클라이언트가 전송할 수 있는 요청 수
        - X-Ratelimit-Retry-After: 제한에 걸리지 않으려면 몇초 뒤에 요청을 보내야 하는지에 대한 정보

7. 분산 환경에서의 처리율 제한에서 중요한 키워드
    - 동시성 제어
        - 고정 세션(처리율 제한 서버도 분산일 경우)
        - 중앙 집중형 데이터 저장소(Redis Cluster)
    - Race Condition
    - 모니터링: 버려지는 요청이 많은지 등. 처리율 제한 알고리즘이 너무 빡빡하진 않은지
        - B2C 환경이면 OK 인데, B2B에서는 확인할 방법ㅇ; ㅣ^\_^ㅑ#\_^ㅑ+\_

<br>

8. 그 외 고려되면 좋을 것들
    - 처리율 제한 임계치를 잠시동안 넘을 수 있는지(Soft) 없는지(Hard)
    - OSI 계층별 처리 제한
    - 클라이언트를 잘 가스라이팅하자
        - 캐시 기능 사용(무한 새로고침 할때)
        - 짧은시간동안 너무 많은 메시지를 보내지 않도록 

<br>

<br>

<br>

- 과제? (현실적인 3개 버킷 구현?)
    - 토큰 버킷
    - 이동 윈도 로그
    - 이동 윈도 카운터

<br>